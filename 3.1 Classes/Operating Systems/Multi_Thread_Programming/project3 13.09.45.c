        /*         CSE3033 PROJECT3                           HELLO THIS IS MULTITHREADING FILE CHANGER PROGRAM         THIS PROGRAM CHANGES GIVEN FILES CONTENT BY REPLACING WHITESCORES WITH UNDER SCORE AND CHANGING LOWER CASES TO UPPER CASE         USAGE OF PROGRAM IS: gcc xpt.c -o xpt -lpthread         ./xpt my_text.txt <n_of read threads> <n_of upper threads> <n_of replace thread> <n_of write threads>                           For yet, only read part is working. The program takes the line_count of file, and creates that counted linked list. Then giving it indexes sequncely.         Insõde read threads, we inserting the lines we took from the file.                  TAHA YUSUF K…M†R: 150114064         Fõrat ‚etiner: 150116027                                                               */        #include <stdio.h>        #include <pthread.h>        #include <stdlib.h>        #include <string.h>        #include <stdbool.h>        #include <time.h>        #include <assert.h>        #include <sys/stat.h>        // Mutexes        pthread_mutex_t lock;        pthread_mutex_t lock_upper;        pthread_mutex_t lock_replacer;        pthread_mutex_t lock_write;        // Globals        static int node_c = 0;   // To trigger rep and upper        char *file_name;        int file_length;        int len_count;        static int iterator = 0;        static int iterator2 = 0;        static int iterator3 = 0;        /*       To keep threads synchronized we use those globals        */        static int replaced_count = 0;        static int uppered_count = 0;        static int readed_count = 0;        static int wrote_count = 0;        static int null_count = 0;        static int writable = 0;        static struct Node *pt;        /*                 Utility Functions                  */        void printList(struct Node *start);   //Prints the linked list        void upper_string(char s[]);          //This function changes string to its upper version.        void replace_all(char *str, char oldChar, char newChar); //This function replace oldChar with newChar in a String, includes all occurences        int * line_lengths(int line_count);   //This function use the given file name and line count of it. Returns integer array. Contents are lengths of each row in File.        void start_indexer(int * arr);       //This function modify the given array depends on each rows depends on start index of File.        int count_lines();//This function counts the length of file        int generate_randoms(int lower, int upper);        void file_updater(char * file_name, char * str, int s_index);        int cfileexists();        struct Node        {            char * line[1];              //storing the line inside here            int index;                   //Index of line            bool uppered;               //For replace control            bool replaced;            bool writed; //For under_score control            pthread_mutex_t  memory_lock; //Memory block pointer            struct Node *next;        };        typedef struct{            pthread_t tid;            int start_index;     //to use fseek, we use start indexes of lines            int r_line;          //read_count per thread            int r_count;         //read_thread count            struct Node *ptr;    //Linked lists header            int remainder;       //If number of lines / number of threads is not integer, we use that remainder to handle        } read_runner;        /* empty yet */        typedef struct {            pthread_t tid;            char *type;            int t_count;            int * start_index;                    } up_rep_write_arg;        /*        Inserting the nodes with spesific struct which include necessary things for the program           */        /*        Which are:                                                                                        */        /*                                                                                                          */        /*        line[] -> store the lines                                                                         */        /*        uppered -> to check uppered or not                                                              */        /*        under_scored -> to check under_scored or not                                                      */        /*        memory_lock -> to lock critical section in the node                                                 */        /*        mutex_init -> to initialize the mutex                                                             */        void insert(struct Node** head_ref)        {                                                            struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));                        new_node->index = node_c;            struct Node *last = *head_ref;            new_node->line[0]= NULL;            new_node->uppered = false;            new_node->replaced = false;            new_node->writed = false;            new_node->next = NULL;            pthread_mutex_init(&new_node->memory_lock, NULL);                                                if (*head_ref == NULL)            {                *head_ref = new_node;                node_c++;                return;            }                        while (last->next != NULL)            {                last = last->next;            }            last->next = new_node;            node_c ++;            return;        }        struct Node * indexOf(struct Node* head_ref, int index){                        struct Node *temp = head_ref;                        while (temp!=NULL)            {                if(index == temp->index)                    return temp;                temp = temp->next;            }            return NULL;        }        struct Node * find_not_uppered(struct Node* head_ref, int size)        {            for(int i = 0; i < size; i++)            {                struct Node *t = indexOf(head_ref, i);                if(t->line[0] != NULL && !(t->uppered))                {                    return t;                }            }                        return NULL;        }        struct Node * find_not_replaced(struct Node* head_ref, int size)        {            for(int i = 0; i < size; i++)            {                struct Node *t = indexOf(head_ref, i);                if(t->line[0] != NULL && !(t->replaced))                {                    return t;                }            }                        return NULL;        }        struct Node * find_uppered_replaced(struct Node* head_ref, int size)        {            for(int i = 0; i < size; i++)            {                struct Node *t = indexOf(head_ref, i);                if(t->line[0] != NULL && t->uppered && t->replaced)                {                    return t;                }            }                        return NULL;        }        /*         To fill the nodes with read thread       */        void insert_line(struct Node* pt, char *str, int index)        {            struct Node *x = indexOf(pt, index);            /*      Allocating space for the line       */                        x->line[0] = malloc(sizeof(char)*(strlen(str)+1));            x->line[0] = str;                    }        /*                           Read Thread                         */        /*      All threads assigned to spesific lines from start       */        void * read(void* arg)        {                        read_runner * st = (read_runner*) arg;                                                char str[255];            FILE* fp = fopen(file_name, "r");            fseek(fp, st->start_index, SEEK_SET);                        int iterator = st->r_line;            if(st->remainder != 0)            {                iterator = st->remainder;            }            for(int i = 0; i < iterator; i++)            {                                fgets(str, sizeof str, fp);                int len = strlen(str);                                char * c = malloc(sizeof(char)*len);                strcpy(c, str);                                pthread_mutex_lock(&lock);                struct Node *t = indexOf(pt, ((st->r_count*st->r_line)+i));                insert_line(pt, c, ((st->r_count*st->r_line)+i));                readed_count++;                printf("READ_%d readed line %d: which is %s \n", st->r_count, t->index, t->line[0]);                pthread_mutex_unlock(&lock);                            }                        fclose(fp);            pthread_exit(0);        }        void* upper(void* arg)        {            up_rep_write_arg * st = (up_rep_write_arg*)arg;                        while(1)            {                                if(uppered_count == len_count)                    break;                                                                                while(readed_count<1)                {                                    }                                                                pthread_mutex_lock(&lock_upper);                iterator++;                struct Node * t = find_not_uppered(pt, iterator&len_count);                if(t)                {                    pthread_mutex_lock(&t->memory_lock);                    upper_string(t->line[0]);                    t->uppered = true;                    uppered_count++;                    printf("UPPER_%d read index %d and converted to %s\n", st->t_count, t->index+1, t->line[0]);                    if(t->replaced == true){                        writable++;                    }                    pthread_mutex_unlock(&t->memory_lock);                }                                pthread_mutex_unlock(&lock_upper);                                            }                                    pthread_exit(0);        }        void* replace(void* arg)        {            up_rep_write_arg * st = (up_rep_write_arg*)arg;            while(1)            {                if(replaced_count == len_count)                    break;                                                while(readed_count < 1)                {                                    }                                pthread_mutex_lock(&lock_replacer);                iterator2++;                struct Node * t = find_not_replaced(pt, iterator2%(len_count+1));                if(t)                {                    pthread_mutex_lock(&t->memory_lock);                    replace_all(t->line[0], ' ', '_');                    t->replaced = true;                    replaced_count++;                    printf("REPLACE_%d read index %d and converted to %s\n", st->t_count, t->index+1, t->line[0]);                    if(t->uppered == true)                    {                        writable++;                    }                    pthread_mutex_unlock(&t->memory_lock);                }                pthread_mutex_unlock(&lock_replacer);            }                                    pthread_exit(0);        }        void* write(void* arg){                        up_rep_write_arg * st = (up_rep_write_arg*)arg;            while(1){                                if(wrote_count > len_count)                {                    break;                }                                while(writable < 1)                {                                    }                iterator3++;                iterator = 0;                pthread_mutex_lock(&lock_write);                struct Node * t = indexOf(pt, iterator3%len_count); // to find node                if(t != NULL){                    if(t->uppered && t->replaced && !(t->writed)){                                                printf("WRITE_%d write line: %d back which is  %s\n ", st->t_count, t->index+1, t->line[0]);                        pthread_mutex_lock(&t->memory_lock);                        file_updater(file_name, t->line[0], st->start_index[t->index]);                        wrote_count++;                                                pthread_mutex_unlock(&t->memory_lock);                    }                }                pthread_mutex_unlock(&lock_write);                            }            pthread_exit(0);        }        /* ********************************************/        /* ********************************************/        /* ***********      MAIN     ********************/        /* *********************************************/        /* *********************************************/        int main(int argc, char **argv)        {            if(cfileexists(argv[2] == 0))            {                printf("Check the file name. \n");                return 1;            }            file_name = argv[2];            len_count = count_lines(); //length of file            file_length = len_count;            int* start_indexes = line_lengths(len_count);            start_indexer(start_indexes);                        if(strcmp(argv[1], "-d") != 0 || strcmp(argv[3], "-n") != 0 || argc < 8)            {                prinftf("Usage of program is: ./project_3.c -d <file_name> -n <read_t> <upper_t> <replace_t> <write_t>  ");                return -1;            }                                    /*                  LOCK INITIALIZE                         */            if (pthread_mutex_init(&lock, NULL) != 0) {                printf("\n mutex init has failed\n");                return 1;            }            if (pthread_mutex_init(&lock_upper, NULL) != 0) {                printf("\n mutex init has failed\n");                return 1;            }            if (pthread_mutex_init(&lock_replacer, NULL) != 0) {                printf("\n mutex init has failed\n");                return 1;            }            if (pthread_mutex_init(&lock_write, NULL) != 0) {                printf("\n mutex init has failed\n");                return 1;            }                                                                        for(int i = 0; i < len_count; i++)            {                printf("%d \n", start_indexes[i]);            }                                                                        // read# -- upper# -- replace# -- write#            int read_t_number = atoi(argv[4]);            int upper_t_number = atoi(argv[5]);            int replace_t_number = atoi(argv[6]);            int write_t_number = atoi(argv[7]);                        //checking if they are >  1, or automatically initialize to 1            if(read_t_number < 1)            {                read_t_number = 1;            }            if(upper_t_number < 1)            {                upper_t_number = 1;            }            if(replace_t_number < 1)            {                replace_t_number = 1;            }            if(write_t_number < 1)            {                write_t_number =1;            }                        //adresses thread id's.            pthread_t read_thread_ids[read_t_number];            pthread_t upper_thread_ids[upper_t_number];            pthread_t replace_thread_ids[replace_t_number];            pthread_t write_thread_ids[write_t_number];                        /*       Initializing the args for read thread       */                        int line_per_read = len_count/read_t_number;            int remainder = 0;            if(len_count != line_per_read*read_t_number)            {                remainder = len_count - (line_per_read*(read_t_number-1));            }                        /*           Initializing the struct_arg                */                        read_runner thread_args [read_t_number];                        up_rep_write_arg thread_args2[upper_t_number+replace_t_number+write_t_number];                                    printf("len_count -> %d\nread_t_number -> %d\nline_per_read -> %d\nremainder -> %d\n", len_count, read_t_number , line_per_read, remainder);                        /* Creating the linked list */            for(int i = 0; i < len_count; i++)            {                insert(&pt);            }                        if(true)            { //Arg creates                                //read                for(int i = 0; i < read_t_number; i++ )                {                    thread_args[i].start_index = start_indexes[i*line_per_read];                    thread_args[i].r_line = line_per_read;                    thread_args[i].r_count = i;                    thread_args[i].ptr = pt;                    thread_args[i].remainder = remainder;                }                //upper                for(int i = 0; i < upper_t_number; i++)                {                                        thread_args2[i].type = "UPPER";                    thread_args2[i].t_count = i;                }                //replace                for(int i = upper_t_number; i < upper_t_number+replace_t_number; i++)                {                                        thread_args2[i].type = "REPLACE";                    thread_args2[i].t_count = i%(upper_t_number);                }                //write                for(int i = upper_t_number+replace_t_number; i < upper_t_number+replace_t_number+write_t_number; i++)                {                    thread_args2[i].type = "WRITE";                    thread_args2[i].t_count = i%(upper_t_number+replace_t_number);                    thread_args2[i].start_index = start_indexes;                }                            }  //End Of Arg creates                                                            //Creating All threads ->            for(int i = 0; i < read_t_number; i++)            {                int chck = pthread_create(&read_thread_ids[i], NULL, read , &thread_args[i]);                if(chck){ printf("Thread could'nt created"); break; }            }                        for(int i = 0; i < upper_t_number; i++)            {                int chck = pthread_create(&upper_thread_ids[i], NULL, upper , &thread_args2[i]);                if(chck){ printf("Thread could'nt created"); break; }            }            for(int i = upper_t_number; i < upper_t_number+replace_t_number; i++)            {                int chck = pthread_create(&replace_thread_ids[i%upper_t_number], NULL, replace , &thread_args2[i]);                if(chck){ printf("Thread could'nt created"); break; }            }                        for(int i = upper_t_number+replace_t_number; i < upper_t_number+replace_t_number+write_t_number; i++)            {                int chck = pthread_create(&replace_thread_ids[i%(upper_t_number+replace_t_number)], NULL, write , &thread_args2[i]);                if(chck){ printf("Thread could'nt created"); break; }            }                                    //Joins                        for(int i = 0; i < read_t_number; i++)            {                pthread_join(read_thread_ids[i], NULL);            }            for(int i = 0; i < upper_t_number; i++)            {                pthread_join(upper_thread_ids[i], NULL);            }            for(int i = 0; i < replace_t_number; i++)            {                pthread_join(replace_thread_ids[i], NULL);            }                                                for(int i = 0; i < write_t_number; i++)            {                pthread_join(write_thread_ids[i], NULL);            }                                        //  printList(pt);                        pthread_mutex_destroy(&lock);            pthread_mutex_destroy(&lock_upper);            pthread_mutex_destroy(&lock_replacer);            pthread_mutex_destroy(&lock_write);                        //   printf("\n\nReaded Count: %d\n\n", readed_count);                                    return 1;        }        /* ********************************************/        /* ********************************************/        /* **********      END OF MAIN    *************/        /* *********************************************/        /* *********************************************/        void file_updater(char * file_name, char * str, int start_index)        {                        FILE *ft = fopen(file_name, "r+");                        fseek(ft, start_index, SEEK_SET);            int i = 0;            char ch;            while ((ch = fgetc(ft)) != '\n' || ch != EOF )            {                                fseek(ft, -1, SEEK_CUR);                if(str[i] == '\0')                    break;                char x = str[i];                fputc(x, ft);                fseek(ft, 0, SEEK_CUR);                i++;                            }            fclose(ft);            return;        }        /*         TO PRINT LIST          */        void printList(struct Node *start)        {            struct Node *temp = start;            printf("\n");            while (temp!=NULL)            {                printf("line no: %d", temp->index);                                if(temp->index < 10){                    printf("    ");                }                else if(temp->index < 100){                    printf("   ");                }                else if(temp->index < 1000){                    printf("  ");                }                else if(temp->index < 10000){                    printf(" ");                }                printf("line: %s", temp->line[0]);                                temp = temp->next;            }        }        /*         To change string to upper           */        void upper_string(char s[]) {            int c = 0;                        while (s[c] != '\0') {                if (s[c] >= 'a' && s[c] <= 'z') {                    s[c] = s[c] - 32;                }                c++;            }        }        /*        To change all occurences of spesific character with new          */        void replace_all(char * str, char oldChar, char newChar)        {            int i = 0;                        /*           Run till end of string              */                        while(str[i] != '\0')            {                                /*           If occurrence of character is found            */                                if(str[i] == oldChar)                {                    str[i] = newChar;                }                                i++;            }        }        int count_lines()        {            FILE *fp;            int line_count = 1;            char c;            fp = fopen(file_name, "r");            if (fp == NULL)            {                printf("Could not open file %s", file_name);                return 0;            }            for(c = getc(fp); c != EOF; c = getc(fp)){                if(c == '\n')                {                    line_count++;                }                            }                        fclose(fp);                                    return line_count;        }        //this function use the given file name and line count of it. Returns integer array. Contents are lengths of each row in File.        int * line_lengths(int line_count)        {                        int *line_lengths = (int *)malloc(line_count*sizeof(int));            if(line_lengths == NULL) { exit(-1); }            int k = 0;            FILE *fp;            int char_count = 0;            char c;            fp = fopen(file_name, "r");            if (fp == NULL)            {                printf("Could not open file %s", file_name);                return 0;            }                        while((c = fgetc(fp)) != EOF){                if(c == '\n')                {                    line_lengths[k] = char_count;                    char_count = 0;                    k++;                }                if(c != '\n') {                    char_count++;                }            }            if (c == EOF)            {                line_lengths[k] = char_count;            }                        fclose(fp);                                    return line_lengths;        }        //this function modify the given array depends on each rows start index on File.        void start_indexer(int * arr)        {            int some_counter = 0;            for( int i = 0; i < file_length; i++) {                int temp = arr[i];                arr[i] = some_counter;                arr[i] += i;                some_counter += temp;            }            arr[0] = 0;                    }        int generate_randoms(int lower, int upper)        {                        int num = (rand() %(upper - lower + 1)) + lower;                                    return num;        }        int cfileexists(const char* filename){            struct stat buffer;            int exist = stat(filename,&buffer);            if(exist == 0)                return 1;            else // -1                return 0;        }